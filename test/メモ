C言語

全体を囲む{}
大文字小文字は区別される
命令終わりは；（一つ一つ命令終了後に書く）
四則計算は同じ
余りを求める％
コメント/* */
インデント（スペースを入れて見やすくすること、改行しなくても；さえあれば処理される）
main関数（C言語は必ずこれから始まる）
.c (C言語の拡張子)
.h(ヘッダーファイル,関数等が入っているファイル)
１ビット　（０、１）
８ビット＝１バイト（２＾８）

プリプロセッサ命令
#include＜ファイル名＞（読み込めという命令、他にもあるけど、、、）
ヘッダーファイルを読み込む
ヘッダーファイルとは関数などの定義が書かれている
#include＜＞（標準ライブラリあるファイル）
#include””（プロジェクトで作成した特有のヘッダーファイル）

関数
１．関数とは
　　{}で括られている
　　ヘッダーファイル内か読み込める
　　標準ライブラリにたくさん定義されている
　　独自に関数を作成することもできる
２．戻り値とは
　　値を返すこと（答え？）
３．引数（ひきすう）
　　関数に渡す値のこと　関数の名前（ここの値が引数）パラメータともいう
４．複数の引数
　　,で区切る　関数の名前（　　　,     )

変数
１．変数とは
　　何らかのデータを入れておく箱のようなもの
　　計算結果などを一時的に保存しておいて、後でそれを使う
２．変数の宣言
　　データ型　変数名
　　変数名はアルファベット、数字、アンダースコア（_)を使用することができる
　　例：int a;
３．変数への値の代入
　　＝を使う
　　　例：int a;
　　　　　a=3+4;
　　　　　int a =3+4;

データ型
１．種類
　  char    文字データ（アルファベット1文字、数値も入れれるが１バイト（２５５）まで）''
    int     整数
    float   小数点
    double  より桁が多い、より小数点が多い場合
    void    何も値がない（変数では使用しない）
２。符号なし変数
　  unsigned char
　  unsigned int
    charは１バイト、０〜２５５ではなく、-127~+127
    プラスだけ使いたい場合はunsignedを使用する、そうすることでプラス側に増える

インクリメント
 一つ加算する
　 a=a+1;　または　a++;
  変数を評価してから１加算する
デクリメント
 一つ減算する
　 a=a-1;　または　a--;
  変数を評価してから１減算する
前置き演算子
　++a;
　--a;
  最初に１加算もしくは減算してから変数を評価する

配列
１．配列とは
　同じ名前で複数の箱を作成すること
　０から始まる
２．配列の宣言
　データ型　変数名［サイズ（箱の個数）］
　例：int a[3]
     a[0]=2
     a[1]=3
     a[2]=5

自作関数
　再使用したいような一律の処理は関数として独立させてそれを呼ぶようにした方が良い
１．関数の定義
　戻り値の型　関数名（引数リスト）{

　処理を記述

　return　呼び出し元に戻す値
}
２．戻り値のない関数の場合
　戻り値がないのでreturnなし
　void 関数名（引数リスト）{

}
３．使用する前に定義する()

関係演算子
　１は真（ｔｒｕｅ）　０は偽（false）
　a > b
　a < b
　a == b(等しいか？、イコールが２つ必要)
　a != b(等しくないか？、ビッっクリマーク使用)
　a && b(両方とも真であるか)
　a || b(どちらかが真であるか)

if文
条件判定して処理を分岐させる
if(条件判定){
　　条件がtrueの場合のみ処理を実行
}
　例：int a,b;
     a = 3
     b = 5

     if(a < b){
       printf("aはbより小さいです")　　全ての処理がされ、trueのみ判定結果が出る
     }
     if(a > b){
       printf("aはbより大きいです")
     }
     if(a == b){
       printf("aはbより等しいです")
     }

else if文
　複数の条件判定の場合上記IFでは全て処理させる無駄があるためtrueのみの処理がされるようにできる
例：int a,b;
     a = 3
     b = 5

     if(a < b){
       printf("aはbより小さいです")　　true処理されたあとは全て飛ばされる
     }
     else if(a > b){
       printf("aはbより大きいです")
     }
    else  if(a == b){
       printf("aはbより等しいです")
     }

else文
　それ以外とういう意味
　どれにも該当しない場合最後が実行される
　例：int a,b;
     a = 3
     b = 5

     if(a < b){
       printf("aはbより小さいです")
     }
     else if(a > b){
       printf("aはbより大きいです")
     }
    else{　　　　　　　　　　　　　　　　　全て該当しない場合はこれが処理される
       printf("aはbより等しいです")　
     }
　二択に使用できる
　例：int a,b;
     a = 3
     b = 5

     if(a < b){
       printf("aはbより小さいです")
     }
    else{
       printf("aはbより等しいです")
     }

三項演算子
　if else文の省略形（１行で書ける）
　式　？　真の場合の処理：偽の場合の処理
　例：a < b ? printf(aはbより小さいです"):printf("aはbより等しいです")

switch文
　ifで分岐させると複雑になりがち（値で応じて振り分ける場合等に使用？）
　switch(値){
　　case 指定値：
　　　　　処理文;
        break; （処理終了、これ入れないと終わらない）
　　case 指定値：
        処理文;
        break;
      default:   (当てはまらない場合、今回は一番最後だからbreak文は必要なし、途中なら必要)
        処理文;
}

　例：int main(){
    　　int a=1;
    　　switch(a){
　　　　　case 1:
　　　　　　printf("1です");
　　　　　　break;
        case 2:
　　　　　　printf("2です");
　　　　　　break;
        default:
　　　　　　printf("3です");
    }
    return 0;
    }

for文
  ループ処理（繰り返し処理）
  カンター変数を用意（何回するか？）
  ループ終了処理を判定（指定した回数の判定）
  ステップの指定（何個づつカウンターを増やすか）
　for(カウンター；判定；ステップ)
　　　　処理文；
　例：int count;
     for(count=0;count<7;count++){
       printf("%d回\n",count+1)
     }

while文
　for文の方が使われやすい
　無限ループになりやすい（わざと無限ループを作れる）
　for文と違って判定文を
　while(条件式){
　}　
　例：int count=o;
     while(count<20){
       printf("%d回目\n",count+1);

       count++;       /*これを入れ忘れると無限ループになる*/
     }

break
　ループから抜け出したい時に使用（そこで終わらす）
　例：for(int count=0;count<7;cout++){
  　  printf("%d回目\n",count+1);
  　  if(count==5)break;
  　　}

continue
　処理を一度スキップしたい時に使用
例：for(int count=0;count<7;cout++){
  　  if(count==5)continue;
  　  printf("%d回目\n",count+1);

  　　}

do while文
　whileとは違ってまず一度実行する
　条件判定が後に来ているので必ず一度は実行される
　whileは最初に条件判定するので、条件に合致しなければ一度も実行されない
　do{
　　　処理
　}while(条件式)
　例：int count=0;
     do{
        printf("%d回目\n",count+1);
        cout++;
     }while(count<7);

多次元配列
　１次元配列
　　０　１　２　３
　２次元配列
   0,0  1,0  2,0  3,0
   0,1  1,1  2,1  3,1
   0,2  1,2  2,2  3,2
   0,3  1,3  2,3  3,3
   データ型　変数名[サイズ1][サイズ2]

文字列
　C言語には文字列型のデータ型がない
　　char型はあくまでもアルファベット１文字文
　文字列の扱い方
　　char型の配列として扱う
　　helloの文字列として扱う
　　　h e l l o 0
　　文字列の終端に０が必要（ヌル文字）
　例：char str[6];
     str[0]='H';
     str[1]='e';
     str[2]='l';
     str[3]='l';
     str[4]='o';
     str[5]=0;

     printf(str);
  　添字を省略した場合はstr[0]を指した事になる

文字列の代入
  char str[6]={'H','e','l','l','o','\0'}; 終端文字を省略してもどちらでもいい
  char str[6]="hello"; ダブルコーテーションで囲んだ場合は自動で\０（ヌル）が入る
  char str[]="hello";

加算代入(+=)
　加算しtから代入処理を簡略化して記述できる
　例：a=a+100;
     a+=100;
減算代入(-=)
 例：a=a-100
    a-=100
乗算代入(*=)
　例：a=a*100
　   a*=100
除算代入(/=)
　例：a=a/100
　   a/=100

strlen関数
文字列の長さを返してくれる(終端文字を除いた文字の個数を調べる)

#include<string.h>
#include<stdio.h>

 int main(){

 char str[]="Hello";

 for(int i=0;i<strlen(str);i++){
    printf("%c\n",str[i]);

 }
return 0;
}

strcpy関数
文字列をコピーする
文字列は＝で代入コピーできないため
#include<string.h>
char str1[20]="Hello World";
char syr2[20]=;

strcpy(str2,str1);
printf("%s¥n",str2);
指定文字数分だけ文字列をコピーすることもできる
strcpy(コピー先、コピー元、文字数)

strcat関数
文字列を連結する
文字列をつなげてポインタを返す
char str1[20]="Hello ";
char syr2[20]="World";

strcmp関数
printf("%s¥n",strcat(sty1,str2));
文字列の比較
文字列の比較に＝＝や！＝は使えないため
＝＝を使用するとメモリアドレスが同じかどうかの判定になる
char str1[20]="Hello World";
char syr2[20]=Hello World";

if(strcmp(str1,str2)==0){
   printf("2つの文字列は同じです");
}
else{
   printf("２つの文字列は違います")
}

ポインタ
メモリのアドレス（番地）を保持している変数
ポインタ変数とも言う
通常の変数は実データを保持、メモリのアドレスを取り出せる
ポインタ変数はおメモリのアドレスを保持、実データにもアクセスできる
ポインタ変数の宣言
　データ型　*変数名；
　int*p_n;
変数からメモリアドレスを取り出す
　＆変数
　P_n=&n;
アドレスから実データを取り出す
　＊変数名
　printf("%d¥n",*p_n);
ポインタ変数から実データを変更
　実データが変更させる
　*p_a=300;
通常変数からアドレスを取り出して、更に実データにアクセス(余り使わない？)
　*(&a)    ＆はアドレスを表示させる　＊は実データを表示させる
　よってかっこがあるためアドレスを表示させてから実データを表示させている（結局実データ）
ポインタのポインタ（これも余り使わない？）
　ポインタは変数のメモリアドレスを保存している変数
　ポインタも変数であることには変わりがない
　ポインタ変数のアドレスもメモリの何処かに保存されている
　データ型　＊＊変数名；
　int a=1;
　int *p_a;
　int **pp_a;

　p_a=&a;
　pp_a=&p_a;

ポインタと配列
配列名はポインタと同じもの
char str[]="Hello World";
char :p_str;
p_str=str;
配列はメモリアドレスが連続しているのでポインタ演算でアクセス出来る
int arry[]={3,5,6,8,32,92,2353};
int *p_arry;

p_arr=arry;

printf("%d\n",*(p_arry+2));

ポインタと文字列
char型のポインタ変数を使って文字列を操作できる
char str[]="Hello World";
　　　　　＝
char *p_str="Hello World";

ポインタと関数
関数に引数としてポインタを渡すことが出来る
通常の関数で実データの場合値をコピーするため重くなる
ポインタ関数の場合直接データにアクセスして変更するため利便性が良い
int add(int a,int　b){
   return a+b;
}

int add2(int *a,int b){
   return =*a+b;
}

add(a,b);

add(&a,b);
